# CVArchitecture
Denver's high-level conceptual design and architecture for connected vehicle deployments.

## Background
Connected vehicle technology, enabling vehicles to communicate with one another and with city infrastructure, holds the potential to dramatically improve the safety of our streets and reduce congestion. This repository serves to capture Denver's conceptual architecture, and shows our approach to implementing connected vehicle technology.

We welcome comments and recommendations, provided as GitHub issues, on our approach. This repo will be a living space for Denver to refine it's achitecture with community input.

## Values
Our approach is based on a set of values we’ve established with our Denver Smart City program:
*	__Embrace__ emerging smart industry standards as they develop
*	__Co-design__ architecture to support multi-vendor interoperability
*	__Maintain__ local control and ownership of City and County of Denver data
*	__Leverage, Collaborate and Contribute__ to open source community innovation and the exchange of knowledge

These values have carried through into the design and architecture we're proposing:

*	Denver will double-down on the investments the U.S. Department of Transportation has made in open source technologies, including the V2I Hub and the Operational Data Environment (ODE).
*	Denver will deploy CV applications as plug-ins on the V2I Hub to maintain interoperability across vendors.
*	Denver will develop API endpoints from it’s cloud environment for external stakeholders, developers, and members of the public.
*	Denver will utilize the USDOT Operational Data Environment to build in best practices for privacy and data security into it’s cloud environment.
*	_Denver will publish other aspects of its code base to make this technology stack function, including device management platforms, other examples?_



From GitHub Guide to Documentation:
Project name: Your project’s name is the first thing people will see upon scrolling down to your README, and is included upon creation of your README file.

Description: A description of your project follows. A good description is clear, short, and to the point. Describe the importance of your project, and what it does.

Table of Contents: Optionally, include a table of contents in order to allow other people to quickly navigate especially long or detailed READMEs.

Installation: Installation is the next section in an effective README. Tell other users how to install your project locally. Optionally, include a gif to make the process even more clear for other people.

Usage: The next section is usage, in which you instruct other people on how to use your project after they’ve installed it. This would also be a good place to include screenshots of your project in action.

Contributing: Larger projects often have sections on contributing to their project, in which contribution instructions are outlined. Sometimes, this is a separate file. If you have specific contribution preferences, explain them so that other developers know how to best contribute to your work. To learn more about how to help others contribute, check out the guide for setting guidelines for repository contributors.

Credits: Include a section for credits in order to highlight and link to the authors of your project.

License: Finally, include a section for the license of your project. For more information on choosing a license, check out GitHub’s licensing guide!




## Documents

Link to:
1. High-level conceptual diagram
2. Architecture Diagram with views
3. Architecture Documentation _(we should post that as native files on GitHub here, or Confluence?)_

Our architecture looks at different “views” of the system, including: Governance, Physical, Logical, Networking, Security, Middleware, and Application.

_This work is made possible by the FHWA Advanced Transportation and Congestion Management Technologies Deployment (ATCMTD) grant._
